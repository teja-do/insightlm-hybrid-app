{
  "name": "InsightsLM - Podcast Generation",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "4c4699bc-004b-4ca3-8923-373ddd4a274e",
        "authentication": "headerAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        32,
        352
      ],
      "id": "4ec830dd-e016-4b1c-8739-b874e5ac1bad",
      "name": "Webhook",
      "webhookId": "4c4699bc-004b-4ca3-8923-373ddd4a274e"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "sources",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "notebook_id",
              "condition": "eq",
              "keyValue": "={{ $('Webhook').item.json.body.notebook_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        240,
        352
      ],
      "id": "9ec05913-33d8-4d93-8b44-8498b7ddfbf5",
      "name": "Get Sources"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "include": "specifiedFields",
        "fieldsToInclude": "title,content",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        464,
        352
      ],
      "id": "a9a1f9af-4c4e-4e8f-ad87-c7e8c6e4e3f5",
      "name": "Aggregate"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a podcast host speaking directly to your audience. You are NOT writing a summary, analysis, or structured document.\n\nFORBIDDEN: Do not write any of these:\n- Bullet points or numbered lists\n- Headers like \"### Section A\" or \"**Key Points:**\"\n- Phrases like \"Here's a structured transcript\" or \"Summary of sources\"\n- Document analysis or content breakdowns\n- ANY formatting beyond plain text paragraphs\n\nREQUIRED: Write exactly like this example - natural speech that flows:\n\n\"You know what's fascinating about the insurance industry today? Most people think they understand their travel coverage, but there's so much complexity hidden beneath the surface. Take this multitrip policy I was looking at recently - the coverage levels are all over the map, and that's actually by design.\n\nLet me paint you a picture. You're planning multiple trips throughout the year, maybe a few weekend getaways, perhaps that big European adventure you've been dreaming about. You call up an insurance company, and they start throwing numbers at you. Essential cover gives you twelve hundred euros for cancellation, but here's the kicker - you're looking at a hundred and fifty euro excess. That's money straight out of your pocket before they pay a cent.\n\nBut then they mention Premier Plus, and suddenly we're talking ten thousand euros with no excess at all. That's a completely different ballgame...\"\n\nYour job: Take the source documents and speak about them naturally, like you're having a conversation with a friend over coffee.\n\nSource text:\n\n######\n\n{{ $json.data.map(item => item.content).join('\\n\\n') }}\n\n######\n\nBegin speaking now - no introductions, no formatting, just natural conversation:",
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        912,
        352
      ],
      "id": "8fea706c-4516-4f97-8fe3-0f9243d623b8",
      "name": "Basic LLM Chain",
      "retryOnFail": true,
      "waitBetweenTries": 5000,
      "maxTries": 5
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=http://kong:8000/storage/v1/object/audio/{{ $('Webhook').item.json.body.notebook_id}}/{{ $binary.data.fileName }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "id": "b8c7b673-03b2-45da-a079-2451de8a0acf",
      "name": "Upload object",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1504,
        352
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=http://kong:8000/storage/v1/object/sign/{{ $json.body.Key }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"expiresIn\": 86400\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1728,
        352
      ],
      "id": "c6cc0139-8a00-4fe6-a945-5c7a85f9b158",
      "name": "Generate Signed URL"
    },
    {
      "parameters": {
        "jsCode": "// Loop over input items and add a new field called 'myNewField' to the JSON of each one\nfor (const item of $input.all()) {\n  const now = new Date();\n  const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000); // Add 1 day in ms\n  item.json.timestamp = tomorrow.toISOString(); // Compatible with Supabase timestampz\n}\n\nreturn $input.all();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1936,
        352
      ],
      "id": "f43fb6d2-9a03-45bc-803d-c1881f47e04b",
      "name": "Generate Timestamp for Expires"
    },
    {
      "parameters": {
        "content": "[![The AI Automators](https://www.theaiautomators.com/wp-content/uploads/2025/03/gray-logo.png)](https://www.theaiautomators.com/)\n## InsightsLM Local - Podcast Generation\nhttps://github.com/theaiautomators/insights-lm-public\nhttps://github.com/theaiautomators/insights-lm-local-package",
        "height": 280,
        "width": 300,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "6a782be9-445b-4b94-a094-ede85651588e",
      "name": "Sticky Note8"
    },
    {
      "parameters": {
        "url": "http://coqui-tts:5002/api/tts",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "style_wav"
            },
            {
              "name": "language_id"
            },
            {
              "name": "speaker_id",
              "value": "p230"
            },
            {
              "name": "text",
              "value": "={{ JSON.stringify($json.text.split(\"</think>\")[1])}}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1280,
        352
      ],
      "id": "1563f249-7a0d-4e2f-b86d-b7872362ea5e",
      "name": "Generate Local Audio"
    },
    {
      "parameters": {
        "jsCode": "// Configuration - Set your desired token limit here\nconst MAX_TOKENS = 2500;\n\n// Simple token estimation function (roughly 4 characters = 1 token)\nfunction estimateTokens(text) {\n  if (!text || typeof text !== 'string') return 0;\n  return Math.ceil(text.length / 4);\n}\n\n// Function to get text content from an item\nfunction getTextContent(item) {\n  let content = '';\n  \n  // Add title if it exists\n  if (item.title) {\n    content += item.title + '\\n';\n  }\n  \n  // Add content if it exists and is not null\n  if (item.content && item.content !== null) {\n    content += item.content + '\\n';\n  }\n  \n  return content;\n}\n\n// Function to truncate text to fit within token limit\nfunction truncateToTokenLimit(text, maxTokens) {\n  const estimatedTokens = estimateTokens(text);\n  \n  if (estimatedTokens <= maxTokens) {\n    return text;\n  }\n  \n  // Calculate approximate character limit\n  const maxChars = maxTokens * 4;\n  return text.substring(0, maxChars) + '...';\n}\n\n// Get the first input item and access its data array\nconst dataArray = $input.first().json.data || [];\n\n// Calculate token budget per item\nconst itemCount = dataArray.length;\nconst tokensPerItem = Math.floor(MAX_TOKENS / itemCount);\n\nconsole.log(`Total items: ${itemCount}, Token budget per item: ${tokensPerItem}`);\n\nlet totalTokensUsed = 0;\nconst processedItems = [];\n\n// Process each item in the data array\nfor (const dataItem of dataArray) {\n  // Get the text content from the data item\n  const textContent = getTextContent(dataItem);\n  const originalTokens = estimateTokens(textContent);\n  \n  // Truncate content to fit within the per-item budget\n  const truncatedContent = truncateToTokenLimit(textContent, tokensPerItem);\n  const finalTokens = estimateTokens(truncatedContent);\n  \n  // Create the processed item\n  const newItem = {\n    ...dataItem,\n    content: truncatedContent,\n    tokenCount: finalTokens,\n    originalTokenCount: originalTokens,\n    truncated: originalTokens > tokensPerItem,\n    tokenBudget: tokensPerItem\n  };\n  \n  processedItems.push(newItem);\n  totalTokensUsed += finalTokens;\n  \n  console.log(`Item: ${dataItem.title}, Original: ${originalTokens}, Final: ${finalTokens}, Truncated: ${originalTokens > tokensPerItem}`);\n}\n\n// Return the result in the same structure as input\nreturn [{\n  json: {\n    data: processedItems,\n    tokenSummary: {\n      totalTokensUsed: totalTokensUsed,\n      maxTokensAllowed: MAX_TOKENS,\n      tokensPerItem: tokensPerItem,\n      itemsProcessed: processedItems.length,\n      averageTokensPerItem: Math.round(totalTokensUsed / processedItems.length)\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        688,
        352
      ],
      "id": "ea77c16f-6d98-422b-811a-79a5f43e77a1",
      "name": "Truncate Sources"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "notebooks",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Webhook').item.json.body.notebook_id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "audio_overview_url",
              "fieldValue": "=http://localhost:8000/storage/v1/{{ $json.signedURL }}"
            },
            {
              "fieldId": "audio_url_expires_at",
              "fieldValue": "={{ $json.timestamp }}"
            },
            {
              "fieldId": "audio_overview_generation_status",
              "fieldValue": "completed"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2160,
        352
      ],
      "id": "c5fd74e4-415d-4a11-8bfe-cd53e6d8e5e6",
      "name": "Update a row"
    },
    {
      "parameters": {
        "content": "## Set Max Tokens to be Processed\n",
        "height": 300,
        "width": 200
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        640,
        208
      ],
      "id": "48908e22-a786-4c8e-8536-6bf288d142ea",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "content": "## Speaker ID can be modified\n",
        "height": 300,
        "width": 200
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1232,
        208
      ],
      "id": "8167e879-fbe7-42b0-b5b2-acf49a733cb6",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "model": "gpt-4.1",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAzureOpenAi",
      "typeVersion": 1,
      "position": [
        960,
        592
      ],
      "id": "c6283c3f-94d7-4736-b62c-a1abce79cfaa",
      "name": "Azure OpenAI Chat Model",
      "credentials": {
        "azureOpenAiApi": {
          "id": "Z76MD3vmxn3tUpIq",
          "name": "Azure Open AI - GPT4.1"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Get Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Sources": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate": {
      "main": [
        [
          {
            "node": "Truncate Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain": {
      "main": [
        [
          {
            "node": "Generate Local Audio",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload object": {
      "main": [
        [
          {
            "node": "Generate Signed URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Signed URL": {
      "main": [
        [
          {
            "node": "Generate Timestamp for Expires",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Timestamp for Expires": {
      "main": [
        [
          {
            "node": "Update a row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Local Audio": {
      "main": [
        [
          {
            "node": "Upload object",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Truncate Sources": {
      "main": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Azure OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "bf1ba054-5ae2-491c-9c7f-242d6c701366",
  "meta": {
    "instanceId": "068244dba05d25bac8988bd5cd582b7345afa2d5e4b550e651dcf42fe5c09e99"
  },
  "id": "4KlLa30rMFb4gnhL",
  "tags": [
    {
      "createdAt": "2025-10-21T18:58:06.070Z",
      "updatedAt": "2025-10-21T18:58:06.070Z",
      "id": "wAqoYDTuctUrtozN",
      "name": "TheAIAutomators.com"
    }
  ]
}